# C# 코딩 컨벤션 및 스타일 가이드 (Unity 3D 프로젝트)

본 문서는 Unity 3D 프로젝트에서 C# 코드의 **일관성, 가독성, 확장성, 유지보수성**을 확보하기 위한 공식 규칙을 정의합니다.  
모든 Pull Request(PR)는 본 문서를 기준으로 리뷰됩니다.

---

# 0. 코드 리뷰 봇 지침 (Gemini Code Assistant)

## 0.1. 리뷰 언어

- 모든 리뷰 요약 및 코멘트는 반드시 **한국어**로 작성합니다.
- 설명은 명확하고 자연스러운 한글로 작성합니다.
- 지적은 비판이 아닌 **개선 제안 형태**로 작성합니다.
- 코드의 문제를 단정하기보다 설계 의도를 분석한 뒤 개선 방향을 제시합니다.

---

## 0.2. 설계 원칙 검토 기준

모든 PR은 아래 항목을 기준으로 설계 원칙을 검토합니다.

---

## 0.2.1. SOLID 원칙 체크리스트

### S — 단일 책임 원칙 (SRP)

- 클래스는 하나의 책임만 가지는가?
- 변경 이유가 두 가지 이상 존재하지 않는가?
- 입력 처리, 로직 처리, UI 갱신이 하나의 클래스에 섞여 있지 않은가?
- Update 내부에 여러 역할이 혼합되어 있지 않은가?

---

### O — 개방-폐쇄 원칙 (OCP)

- 타입 분기를 위해 if/switch를 반복 사용하고 있지 않은가?
- 새로운 기능 추가 시 기존 코드 수정이 필요한 구조인가?
- 인터페이스 또는 전략 패턴으로 확장 가능하도록 설계되어 있는가?

---

### L — 리스코프 치환 원칙 (LSP)

- 상위 타입을 하위 타입으로 치환해도 동일하게 동작하는가?
- override 메서드에서 부모 계약을 위반하지 않는가?
- 특정 하위 타입에서만 예외를 던지는 구조는 아닌가?

---

### I — 인터페이스 분리 원칙 (ISP)

- 사용하지 않는 메서드를 강제로 구현하고 있지 않은가?
- 인터페이스가 과도하게 큰 책임을 갖고 있지 않은가?
- 단일 목적의 작은 인터페이스로 분리할 수 없는가?

---

### D — 의존성 역전 원칙 (DIP)

- MonoBehaviour가 구체 클래스에 직접 의존하고 있지 않은가?
- new 키워드로 의존 객체를 직접 생성하고 있지 않은가?
- 추상화(인터페이스, 추상 클래스)에 의존하고 있는가?

---

## 0.2.2. 디미터의 법칙 (Law of Demeter)

### 핵심 원칙

> 객체는 오직 자신의 직접적인 협력 객체와만 상호작용해야 한다.

### 허용 범위

메서드 내부에서 호출 가능한 객체:

1. 자기 자신
2. 매개변수로 전달된 객체
3. 현재 객체의 필드
4. 메서드 내에서 생성한 객체

### 금지 패턴

- 점(.)이 연속 3회 이상 사용되는 호출
- 내부 구조를 탐색하는 체이닝 호출
- 데이터 구조를 외부에서 조작하는 코드

### 권장 방식

- 데이터가 아닌 “행동”을 요청한다.
- 내부 구조를 숨기고 의미 있는 메서드를 노출한다.

---

# 1. Unity 특화 설계 원칙

## 1.1. MonoBehaviour 사용 원칙

MonoBehaviour는 **조정자(Coordinator)** 역할만 수행한다.

MonoBehaviour의 책임:

- 입력 감지
- Unity 이벤트 수신
- Inspector 연결
- 외부 시스템과 연결

비즈니스 로직은 순수 C# 클래스에서 처리한다.

---

## 1.2. Update 사용 규칙

- Update 사용을 최소화한다.
- 이벤트 기반 또는 상태 기반 구조를 우선한다.
- 조건문이 많은 Update는 SRP 위반 가능성이 높다.
- 시간 기반 처리에는 명확한 책임 분리가 필요하다.

---

## 1.3. SerializedField 사용 규칙

- 외부 수정이 필요 없는 필드는 private + `[SerializeField]` 사용
- 사용하지 않는 SerializedField는 제거
- 런타임 전용 데이터는 Serialize하지 않는다
- Inspector 노출은 의도적으로 제한한다

---

# 2. 보이스카웃 법칙 (Scout Rule)

> 코드를 항상 내가 발견했을 때보다 더 깨끗하게 남긴다.

## 적용 조건

- 기존 파일을 수정하는 경우에만 강제 적용
- 신규 파일에는 권장 사항으로 적용

## 정리 대상

- 불필요한 using 제거
- 죽은 코드 제거
- 의미 없는 변수명 개선
- 중복 코드 제거
- 긴 메서드 분리
- null 위험 코드 방어

PR은 기능 추가뿐 아니라 **코드 개선을 포함해야 한다.**

---

# 3. 언어 사용 규칙

## 3.1. 최신 C# 기능 활용

- Pattern Matching 적극 활용
- Switch Expression 사용 권장
- Record 사용 권장 (데이터 전용 객체)
- Init 접근자 활용
- Expression-bodied 멤버는 가독성을 해치지 않는 범위에서 사용

---

## 3.2. 데이터 형식

- `System.Int32` 대신 `int` 사용
- 부호 없는 타입보다 `int` 선호
- 명확성보다 축약을 우선하지 않는다

---

## 3.3. var 사용 규칙

- 타입이 명확히 드러나는 경우에만 사용
- 반환 타입이 불명확한 메서드 호출에는 사용하지 않는다
- 가독성을 해치면 사용하지 않는다

---

## 3.4. 문자열 처리

- 짧은 문자열 연결은 문자열 보간 사용
- 반복문 내 대량 문자열 연결은 `StringBuilder` 사용
- 긴 메시지는 Raw String Literal 사용 권장

---

## 3.5. 컬렉션 초기화

- 컬렉션 식(`[]`) 사용
- 명시적 타입이 필요한 경우만 타입 선언

---

## 3.6. 예외 처리

- catch(Exception) 사용 금지
- 처리 가능한 구체적 예외만 catch
- 예외를 로그만 남기고 무시하지 않는다
- 도메인 의미를 가지는 예외로 변환 권장

---

# 4. 명명 규칙 (Naming Conventions)

## 4.1. PascalCase

적용 대상:

- 클래스
- 구조체
- 레코드
- 인터페이스 (I 접두사 사용)
- public 멤버
- 상수

---

## 4.2. camelCase

적용 대상:

- 지역 변수
- 매개변수

---

## 4.3. 필드 접두사

| 대상 | 접두사 |
|------|--------|
| Private 인스턴스 필드 | `_` |
| Static 필드 | `s_` |
| Thread Static 필드 | `t_` |

---

## 4.4. 일반 원칙

- 간결성보다 명확성을 우선한다.
- 단일 문자 변수명은 루프 카운터 외 사용 금지.
- Manager, Controller 남용 금지.
- 역할 중심 네이밍 사용.

---

# 5. 레이아웃 및 포맷

- 들여쓰기: 4 spaces
- 탭 사용 금지
- Allman 스타일 중괄호 사용
- 한 줄에 하나의 문장만 작성
- 메서드 간 최소 1줄 공백
- 주석은 별도 줄에 작성
- XML 주석은 public API 및 복잡한 로직에만 작성

---

# 6. 구조 제한 기준

## 클래스 길이

- 300줄 이상: 책임 점검
- 500줄 이상: 분리 검토 필수

## 메서드 길이

- 30줄 이상: 분리 고려
- 하나의 추상화 수준만 유지

---

# 7. PR 승인 기준

## 승인 가능

- SOLID 강화
- LoD 개선
- 의존성 감소
- 테스트 가능성 증가
- 기존 코드 구조 개선

## 변경 요청

- 결합도 증가
- MonoBehaviour 과도한 책임
- God Class 발생
- 조건문 기반 타입 분기 구조
- 내부 구조 노출

---

# 8. 자동화 및 CI

- `.editorconfig` 필수 적용
- Roslyn Analyzer 사용
- IDE 규칙 동기화
- CI에서 규칙 위반 시 경고 이상 발생

---

# 9. 팀 개발 문화

- 코드 품질은 기능과 동일한 우선순위
- 빠른 구현보다 올바른 구조
- 이해하기 쉬운 코드가 좋은 코드
- 설계는 미래의 자신을 위한 문서다

---